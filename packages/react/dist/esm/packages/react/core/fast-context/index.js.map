{"version":3,"file":"index.js","sources":["../../../../../../core/fast-context/index.tsx"],"sourcesContent":["import { shallowCompare } from '@binaryoperations/json-forms-internals/object';\nimport {\n  type ComponentType,\n  type Context,\n  createContext,\n  memo,\n  type MutableRefObject,\n  PropsWithChildren,\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n} from 'react';\nimport { useSyncExternalStoreWithSelector } from 'use-sync-external-store/with-selector';\n\nimport { useInvariantContext } from '../hooks/useInvariantContext';\nimport { useLatest } from '../hooks/useLatest';\nimport { usePrevious } from '../hooks/usePrevious';\n\ntype StoreDataType = NonNullable<object>;\n\ntype Selector<IStore, SelectorOutput> = (store: IStore) => SelectorOutput;\ntype EqualityCheck = (prev: any, next: any) => boolean;\n\ntype UseStoreDataReturnType<IStore extends StoreDataType = StoreDataType> = {\n  get: () => IStore;\n  set: (value: (prev: IStore) => Partial<IStore>) => void;\n  store: MutableRefObject<IStore>;\n  subscribe: (callback: () => void) => () => void;\n};\n\nconst useStoreData = <IStore extends StoreDataType = StoreDataType>(\n  value: IStore,\n  onChange?: (nextValue: IStore) => void,\n  watch = false\n): UseStoreDataReturnType<IStore> => {\n  const store = useRef<IStore>(value as IStore);\n  const watchRef = useRef(watch);\n  const effectRef = useRef(false);\n  const onChangeRef = useLatest(onChange);\n\n  const get = useCallback(() => store.current, [store]);\n\n  const subscribers = useRef(new Set<() => void>());\n\n  const set = useCallback(\n    (callback: (prev: IStore) => Partial<IStore>) => {\n      store.current = { ...store.current, ...callback(store.current) };\n      if (!effectRef.current && onChangeRef.current)\n        onChangeRef.current(store.current);\n      else subscribers.current.forEach((subscriber) => subscriber());\n      effectRef.current = false;\n    },\n    [store, onChangeRef]\n  );\n\n  const subscribe = useCallback((callback: () => void) => {\n    subscribers.current.add(callback);\n    return () => subscribers.current.delete(callback);\n  }, []);\n\n  /**\n   *\n   * The effect is required to trigger the updates on the consumers\n   */\n  useEffect(() => {\n    if (!watchRef.current) return;\n    effectRef.current = true;\n    set(() => value);\n  }, [set, store, value]);\n\n  /**\n   *\n   * Cases:\n   * 1. when the value updates, we want the data to be updated immediately\n   * 2. the data stored in store.current may not be current with regards to the parent and the parent must have dropped the references related to the data.\n   * 3. because store.current is a ref, on watch and change, if we update store.current, no side-effect introduced.\n   */\n  if (usePrevious(value).current !== value && watchRef.current) {\n    store.current = { ...store.current, ...value };\n  }\n\n  return useMemo(\n    () => ({\n      get,\n      set,\n      subscribe,\n      store,\n    }),\n    [get, set, subscribe]\n  );\n};\n\nexport type ProviderProps<T> = PropsWithChildren<{\n  value: T;\n  onChange?: (nextValue: T) => void;\n}>;\n\ntype CreateFastContextConfig =\n  | boolean\n  | { watch?: boolean; debugName?: string };\n\nexport type CreateFastContext<T extends StoreDataType = StoreDataType> = (\n  config?: CreateFastContextConfig\n) => {\n  useStoreRef: ReturnType<typeof createUseRefContext<T>>;\n  Provider: ComponentType<ProviderProps<T>>;\n  useContext: <SelectorResult>(\n    selector: Selector<T, SelectorResult>,\n    equalityCheck: EqualityCheck\n  ) => [\n    selectedResult: SelectorResult,\n    setValue: UseStoreDataReturnType<T>['set'],\n  ];\n  useContextValue: <SelectorResult>(\n    selector: Selector<T, SelectorResult>,\n    equalityCheck: EqualityCheck\n  ) => SelectorResult;\n};\n\nlet counter = 0;\nexport const createFastContext = <T extends StoreDataType = StoreDataType>(\n  config?: CreateFastContextConfig\n) => {\n  const { watch = false, debugName = `fast-context-${++counter}` } =\n    typeof config !== 'object' ? { watch: config } : config;\n\n  const context = createContext<UseStoreDataReturnType<T> | null>(null);\n  context.displayName = debugName;\n\n  return {\n    /**\n     * using the value from here will never cause a rerender as context is based on refs.\n     */\n    useStoreRef: createUseRefContext(context),\n\n    /**\n     *\n     * the value is memoized and thus changing the value will have no effect.\n     * use key prop to unmount and remount if necessary. alternatively use set from the context to update the value.\n     *\n     */\n    Provider: createProvider<T>(\n      context as Context<UseStoreDataReturnType<T>>,\n      watch\n    ),\n\n    /**\n     *\n     * @param selector\n     * @param equalityCheck\n     * @returns tuple, first item is return value of the selector and the second item is setter\n     *\n     */\n    useContext: <SelectorOutput,>(\n      selector: Selector<T, SelectorOutput>,\n      equalityCheck: EqualityCheck = shallowCompare\n    ) => useFastContextStore(context, selector, equalityCheck),\n\n    /**\n     *\n     * @param selector\n     * @param equalityCheck\n     * @returns return value of the selector\n     *\n     */\n    useContextValue: <SelectorOutput,>(\n      selector: Selector<T, SelectorOutput>,\n      equalityCheck: EqualityCheck = shallowCompare\n    ) => useStoreValue(context, selector, equalityCheck),\n\n    /**\n     * context of the store. Useful for ContextBridge\n     */\n    Context: context,\n  };\n};\n\nexport const createProvider = <T extends StoreDataType = StoreDataType>(\n  StoreContext: Context<UseStoreDataReturnType<T>>,\n  watch: boolean\n) => {\n  return Object.assign(\n    memo(function CreateFastContext({\n      value,\n      children,\n      onChange,\n    }: ProviderProps<T>) {\n      return (\n        <StoreContext.Provider value={useStoreData<T>(value, onChange, watch)}>\n          {children}\n        </StoreContext.Provider>\n      );\n    }),\n    { displayName: StoreContext.displayName }\n  );\n};\n\nexport const createUseRefContext = <T extends StoreDataType = StoreDataType>(\n  _Context: Context<UseStoreDataReturnType<T> | null>\n) => {\n  return () => {\n    const value = useInvariantContext(\n      _Context,\n      'Fast Context requires the value to be wrapped in a Provider with a value.'\n    );\n    return value;\n  };\n};\n\nexport const useFastContextStore = <\n  IStore extends StoreDataType,\n  SelectorOutput,\n>(\n  _Context: Context<UseStoreDataReturnType<IStore> | null>,\n  selector: Selector<IStore, SelectorOutput>,\n  equalityFn = Object.is\n): [value: SelectorOutput, set: UseStoreDataReturnType<IStore>['set']] => {\n  const store = useInvariantContext(_Context, 'Store not found');\n\n  const state = useSyncExternalStoreWithSelector(\n    store.subscribe,\n    () => {\n      return store.get();\n    },\n    undefined,\n    (snapshot) => {\n      return selector(snapshot);\n    },\n    equalityFn\n  );\n\n  return [state, store.set];\n};\n\nexport const useStoreValue = <IStore extends StoreDataType, SelectorOutput>(\n  _Context: Context<UseStoreDataReturnType<IStore> | null>,\n  selector: Selector<IStore, SelectorOutput>,\n  equalityFn = Object.is\n) => {\n  return useFastContextStore(_Context, selector, equalityFn)[0];\n};\n"],"names":["useStoreData","value","onChange","watch","store","useRef","watchRef","effectRef","onChangeRef","useLatest","get","useCallback","subscribers","set","callback","subscriber","subscribe","useEffect","usePrevious","useMemo","counter","createFastContext","config","debugName","context","createContext","createUseRefContext","createProvider","selector","equalityCheck","shallowCompare","useFastContextStore","useStoreValue","StoreContext","memo","children","_jsx","_Context","useInvariantContext","equalityFn","useSyncExternalStoreWithSelector","snapshot"],"mappings":"8jBA+BA,MAAMA,EAAe,CACnBC,EACAC,EACAC,EAAQ,KAC0B,CAC5B,MAAAC,EAAQC,SAAeJ,CAAe,EACtCK,EAAWD,SAAOF,CAAK,EACvBI,EAAYF,SAAO,EAAK,EACxBG,EAAcC,EAAUP,CAAQ,EAEhCQ,EAAMC,EAAAA,YAAY,IAAMP,EAAM,QAAS,CAACA,CAAK,CAAC,EAE9CQ,EAAcP,EAAAA,OAAW,IAAA,GAAiB,EAE1CQ,EAAMF,cACTG,GAA+C,CACxCV,EAAA,QAAU,CAAE,GAAGA,EAAM,QAAS,GAAGU,EAASV,EAAM,OAAO,GACzD,CAACG,EAAU,SAAWC,EAAY,QACxBA,EAAA,QAAQJ,EAAM,OAAO,EAC9BQ,EAAY,QAAQ,QAASG,GAAeA,EAAY,CAAA,EAC7DR,EAAU,QAAU,EAAA,EAEtB,CAACH,EAAOI,CAAW,CAAC,EAGhBQ,EAAYL,cAAaG,IACjBF,EAAA,QAAQ,IAAIE,CAAQ,EACzB,IAAMF,EAAY,QAAQ,OAAOE,CAAQ,GAC/C,CAAE,CAAA,EAMLG,OAAAA,EAAAA,UAAU,IAAK,CACRX,EAAS,UACdC,EAAU,QAAU,GACpBM,EAAI,IAAMZ,CAAK,EACd,EAAA,CAACY,EAAKT,EAAOH,CAAK,CAAC,EASlBiB,EAAYjB,CAAK,EAAE,UAAYA,GAASK,EAAS,UACnDF,EAAM,QAAU,CAAE,GAAGA,EAAM,QAAS,GAAGH,IAGlCkB,UACL,KAAO,CACL,IAAAT,EACA,IAAAG,EACA,UAAAG,EACA,MAAAZ,CAEF,GAAA,CAACM,EAAKG,EAAKG,CAAS,CAAC,CAEzB,EA6BA,IAAII,EAAU,EACD,MAAAC,EACXC,GACE,CACF,KAAM,CAAE,MAAAnB,EAAQ,GAAO,UAAAoB,EAAY,gBAAgB,EAAEH,CAAO,EAAE,EAC5D,OAAOE,GAAW,SAAW,CAAE,MAAOA,CAAW,EAAAA,EAE7CE,EAAUC,gBAAgD,IAAI,EACpE,OAAAD,EAAQ,YAAcD,EAEf,CAIL,YAAaG,EAAoBF,CAAO,EAQxC,SAAUG,EACRH,EACArB,CAAK,EAUP,WAAY,CACVyB,EACAC,EAA+BC,IAC5BC,EAAoBP,EAASI,EAAUC,CAAa,EASzD,gBAAiB,CACfD,EACAC,EAA+BC,IAC5BE,EAAcR,EAASI,EAAUC,CAAa,EAKnD,QAASL,CAAA,CAEb,EAEaG,EAAiB,CAC5BM,EACA9B,IAEO,OAAO,OACZ+B,OAAK,SAA2B,CAC9B,MAAAjC,EACA,SAAAkC,EACA,SAAAjC,GACiB,CAEf,OAAAkC,MAACH,EAAa,SAAS,CAAA,MAAOjC,EAAgBC,EAAOC,EAAUC,CAAK,YACzD,CAAA,CAGd,CAAA,EACD,CAAE,YAAa8B,EAAa,WAAa,CAAA,EAIhCP,EACXW,GAEO,IACSC,EACZD,EACA,2EAA2E,EAMpEN,EAAsB,CAIjCM,EACAT,EACAW,EAAa,OAAO,KACmD,CACjE,MAAAnC,EAAQkC,EAAoBD,EAAU,iBAAiB,EActD,MAAA,CAZOG,EAAAA,iCACZpC,EAAM,UACN,IACSA,EAAM,MAEf,OACCqC,GACQb,EAASa,CAAQ,EAE1BF,CAAU,EAGGnC,EAAM,GAAG,CAC1B,EAEa4B,EAAgB,CAC3BK,EACAT,EACAW,EAAa,OAAO,KAEbR,EAAoBM,EAAUT,EAAUW,CAAU,EAAE,CAAC"}